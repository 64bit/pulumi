// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
'use strict';

import * as packageJson from "../package.json";
import * as opentelemetry from "@opentelemetry/api";
import { Resource } from "@opentelemetry/resources";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { BatchSpanProcessor, SimpleSpanProcessor } from "@opentelemetry/sdk-trace-base";
import { ZipkinExporter } from "@opentelemetry/exporter-zipkin";
import { GrpcInstrumentation } from "@opentelemetry/instrumentation-grpc";
import { NodeTracerProvider } from "@opentelemetry/sdk-trace-node";
import { registerInstrumentations } from "@opentelemetry/instrumentation";
import * as log from "../log";

let exporter: ZipkinExporter;
let rootSpan: opentelemetry.Span;

// serviceName is the name of this service in the Pulumi
// distributed system, and the name of the tracer we're using.
const serviceName = "nodejs-runtime";

// If the URL provided matches the default generated by the engine,
// we must transform it to be compatible with the OpenTelemetry Zipkin
// library.
function transformUrl(original: string): string {
  if (original.startsWith("tcp://127.0.0.1")) {
    // We wish to modify the URL to use the v1 Zipkin API over HTTP.
    // But we also want to preserve the port number.
    let modified = new URL(original);
    modified.pathname = "/api/v1/spans";
    // NodeJS does not let you mutate a URL object's protocol field
    // from tcp to http because tcp is not considered a "special" scheme.
    // Instead, we perform the modification ourself with a regex match.
    // https://nodejs.org/api/url.html#urlprotocol
    const modifiedUri = modified.toString().replace(/^tcp/, "http");
    log.warn(`tcp protocol detected in the tracing URI. This URI is not compatible with the OpenTelemetry Zipkin exporter, so a compatible URL will be used instead: ${modifiedUri}`);
    return modifiedUri;
  }
  return original;
}

export function start(destinationUrl: string) {
  const url = transformUrl(destinationUrl);
  // Set up gRPC auto-instrumentation.  
  registerInstrumentations({
    instrumentations: [new GrpcInstrumentation()],
  });

  // Tag traces from this program with metadata about their source.
  const resource = Resource.default().merge(
    new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
      [SemanticResourceAttributes.SERVICE_VERSION]: packageJson.version,
    })
  );

  // Create a new tracer provider, acting as a factory for tracers.
  const provider = new NodeTracerProvider({
    resource: resource,
  });
  
  // Configure span processor to send spans to the exporter
  log.debug(`Registering tracing url: ${url}`);
  exporter = new ZipkinExporter({url});
  provider.addSpanProcessor(new SimpleSpanProcessor(exporter));

  /**
   * Taken from OpenTelemetry Examples (Apache 2 License):
   * https://github.com/open-telemetry/opentelemetry-js/blob/a8d39317b5daad727f2116ca314db0d1420ec488/examples/basic-tracer-node/index.js
   * Initialize the OpenTelemetry APIs to use the BatchTracerProvider bindings.
   *
   * A "tracer provider" is a factory for tracers. By registering the provider,
   * we allow tracers of the given type to be globally contructed.
   * As a result, when you call API methods like
   * `opentelemetry.trace.getTracer`, the tracer is generated via the tracer provder
   * registered here.
   */
  provider.register();
  const tracer = opentelemetry.trace.getTracer("nodejs-runtime");
  // Create a root span, which must be closed.
  rootSpan = tracer.startSpan("nodejs-runtime-root");
}

export function stop() {
  log.debug("Shutting down tracer.");
  // Always close the root span.
  rootSpan.end();
  // Do not bother stopping the tracing exporter. Because we use a
  // SimpleSpanProcessor, it eagerly sends spans.
}

export function newSpan(name: string): opentelemetry.Span {
  const tracer = opentelemetry.trace.getTracer(serviceName);
  const parentSpan = opentelemetry.trace.getActiveSpan() ?? rootSpan;
  const activeCtx = opentelemetry.context.active();
  const ctx = opentelemetry.trace.setSpan(activeCtx, parentSpan);
  const childSpan = tracer.startSpan(name, undefined, ctx);
  return childSpan;
}
