package myrandom

import (
	"hash/crc32"
)

type RandomBytesArgs struct {
	// The number of random bytes to generate.
	Count uint `pulumi:"count,immutable"`
	// The generation ID of the random bytes, if any.
	Generation string `pulumi:"generation,optional,immutable"`
}

// A RandomBytes resource generates a number of random bytes. The byte contents do not change from
// run to run unless the "generation" parameter changes.
//
//pulumi:resource
type RandomBytes struct {
	// The number of random bytes to generate.
	Count uint `pulumi:"count,immutable"`
	// The generation ID of the random bytes, if any.
	Generation string `pulumi:"generation,optional,immutable"`
	// The generated bytes.
	Bytes []byte `pulumi:"bytes"`
}

func (r *RandomBytes) Args() *RandomBytesArgs {
	return &RandomBytesArgs{
		Count:      r.Count,
		Generation: r.Generation,
	}
}

func (r *RandomBytes) Create(ctx *provider.Context, p *Provider, args *RandomBytesArgs, options provider.CreateOptions) (provider.ID, error) {
	r.Bytes = p.randomBytes(int(args.Count))

	// Use the CRC32 of the bytes as the ID so Read can decide whether or not to return an error.
	hash := crc32.ChecksumIEEE(r.Bytes)
	return provider.ID(fmt.Sprintf("%v", hash)), nil
}

func (r *RandomBytes) Read(ctx *provider.Context, id provider.ID, p *Provider, options provider.ReadOptions) error {
	// Random resources cannot be read unless they have already been materialized.
	hash := crc32.ChecksumIEEE(r.Bytes)
	if fmt.Sprintf("%v", hash) == string(id) {
		return nil
	}
	return provider.NotFound("provider resources cannot be read")
}

func (r *RandomBytes) Update(ctx *provider.Context, p *Provider, id provider.ID, args *RandomBytesArgs, options provider.UpdateOptions) error {
	// This resource should never be updated. Treat this as a no-op.
	return nil
}

func (r *RandomBytes) Delete(ctx *provider.Context, p *Provider, id provider.ID, args *RandomBytesArgs, options provider.DeleteOptions) error {
	// This is a no-op.
	return nil
}
